<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">

    <title>YAB - Haproxy as SSL Termination</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1><a href="" class="a-hover">YAB - Yet Another Blog</a></h1>
        <h2>Haproxy as SSL Termination</h2>

        <section id="downloads">
          <a href="https://github.com/ibizaman" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
          <p>First, let's dive into what I want to achieve.</p>
          <p>I want Plex to be running on port 32400 of a server I own.
              Access from outside will be made possible by opening
              a port on my router to forward incoming connections
              arriving on port 32400 to the internal IP of my server on
              port 32400.</p>
          <p>I also want to access my server with a domain name instead
              of knowing it's external IP address by heart, so I have
              a godaddy account with a domain I bought.</p>
          <p>Finally, I want to access Plex with a secured https
              connection. This will be done by using Let's Encrypt to
              create certificates and setup Plex to use them.</p>
          <p>Let's get started!</p>

          <h2>Setup a Domain</h2>
          <p>First let's make the server accessible through a domain.</p>
          <p>For that, go to <a href="https://www.godaddy.com">Godaddy</a>,
              buy your dream domain name and make it point to your
              server's external IP address by adding a A record:</p>
          <pre>Type  Name  Value          TTL<br>A     @     167.32.23.254  600 seconds</pre>
          <p><span class="code">167.32.23.254</span> is an example
              external IP address. To know yours, the simplest is to
              query the amazingly <i>free</i> service
              <a href="https://www.ipify.org/">ipify.org</a>. Just issue, on the server:</p>
          <pre>curl 'https://api.ipify.org'</pre>
          <p>That will return you current external IP address.</p>

          <h3>Dynamic IP Address</h3>
          <p>In my case, it does not end there. In fact my server has
              a dynamic external IP. So I need something monitoring
              changes in my external IP and updating the Godaddy
              A record. For that, I simply use the script
              <a href="https://github.com/AndreasLoow/godaddy-dyndns">godaddy-dyndns</a>.
              Follow the link to get some very easy installation
              instructions. You will see that the script uses ipify.org
              too. :)</p>
          <p>The only difference in what I did with the instructions in
              the link is that I use
              <a href="http://fcron.free.fr/doc/en/fcrontab.5.html">fcrontab</a>,
              instead of crontab. It is installed with:</p>
          <pre>sudo pacman -S fcrontab</pre>

          <h2>Install Plex</h2>
          <p>Next step is installing Plex.</p>
          <p>My server runs the Arch Linux distribution. There, Plex is
              available through an
              <a href="https://aur.archlinux.org/packages/plex-media-server-plexpass/">AUR package aur/plex-media-server-plexpass</a>.
              It is installed with:</p>
          <pre>yaourt aur/plex-media-server-plexpass</pre>
          <p>And the two relevant directories are thus in my case:</p>
          <pre>/opt/plexmediaserver  <span class="comment"># install dir</span><br>/var/lib/plex         <span class="comment"># work dir</span></pre>
          <p>We need to keep that in mind for later.</p>
          <p>As usual on Arch Linux, daemons are managed through systemd
              so to start Plex and make it start on boot, run:</p>
          <pre>sudo systemctl start plexmediaserver<br>sudo systemctl enable plexmediaserver</pre>
          <p>By default, Plex runs on port
              <span class="code">32400</span>, so that's good.</p>

          <h2>Access Plex from Outside</h2>
          <p>I then make Plex accessible from outside on port
              <span class="code">32400</span>. Say you bought the
              mydream.com domain, you will access Plex by going to
              <a href="http://mydream.com:32400">http://mydream.com:32400</a>.</p>
          <p>To make this happen, I forward the external port 32400 to
              the internal port 32400 on the IP address 192.168.1.100.
              I do this by configuring my router. Although instead of
              using its often clunky web interface, I rather use a neat
              little tool called
              <a href="http://miniupnp.free.fr/">upnpc</a>. It is
              installed with:</p>
          <pre>sudo pacman -S community/miniupnpc</pre>
          <p>This tool allows you to remotely add and remove port
              forwarding on routers supporting the UPNP protocol. In our
              case, we want to add a port forwarding so we issue:
          <pre>upnpc -a 192.168.1.100 32400 32400 tcp</pre>
          <p>The tool is a tad verbose, but at the end you can see it
              succeeded. By the way, that tool also allows you to get
              your external IP as seen by your router, but it is burried
              in the output so less usable in scripts.</p>
          <p>Now you can access Plex from outside, but with an
              <i>insecure</i> connection.</p>
         
          <h2>Plex on https</h2>
          <p>This step is a little more involved in scripts. What I do
              is use Let's Encrypt to create and renew certificates for
              Plex. Plex is configured to use them but it does not
              understand the format that Let's Encrypt outputs, so there
              is a little conversion step involved. This certificate
              issuing will be done periodically using fcron as it needs
              to be done at least every 4 months. Finally, Let's Encrypt
              works by having a local webserver handling stuff (sorry,
              I'm bad at crypto) before issuing the certificates. The
              webserver we will put in place is
              <a href="http://www.haproxy.org/">haproxy</a> with a plugin
              <a href="https://github.com/janeczku/haproxy-acme-validation-plugin">plugin</a>
              that handles everything seamlessly for us.</p>
          <p>To setup all this, we will use everything we learned until
              now. Nice!</p>

          <h3>Setup haproxy</h3>
          <p>First, we will install haproxy</p>
          <pre>sudo pacman -S community/haproxy</pre>
          <p>And the haproxy plugin with:</p>
          <pre>sudo mkdir /etc/haproxy/plugins<br>sudo curl -o /etc/haproxy/plugins/haproxy-acme-validation-plugin-0.1.1 \<br>    https://raw.githubusercontent.com/janeczku/haproxy-acme-validation-plugin/master/acme-http01-webroot.lua</pre>
          <p>The configuration file of haproxy is
              <span class="code">/etc/haproxy/haproxy.cfg</span>.
              If you meet haproxy for the first time, I would advice
              using the
              <span class="code">/etc/haproxy/haproxy.cfg.sample</span>
              file as a basis. From it, you can add the two global lines
              hereunder and remove all frontend and backend sections and
              replace them with the only frontend section hereunder.</p>
          <p>In any case, I used and changed a bit the configuration from
              <a href="https://blog.brixit.nl/automating-letsencrypt-and-haproxy">this blog post</a>.
              Thanks martijn for doing all the hard work!</p>
          <pre>global
    lua-load /etc/haproxy/plugins/haproxy-acme-validation-plugin-0.1.1/acme-http01-webroot.lua
    tune.ssl.default-dh-param  2048

frontend  http
    bind *:1000
    acl url_acme_http01  path_beg       /.well-known/acme-challenge/

    http-request use-service lua.acme-http01 if METH_GET url_acme_http01</pre>
          <ul>
              <li>The <span class="code">lua-load</span> line loads the
                  plugin handling Let's Encrypt request.</li>
              <li>The <span class="code">tune.ssl.*</span> line is
                  needed to remove a warning issued by haproxy. Using
                  2048 instead of the default 1024 makes the connection
                  stronger (see, bad in crypto).</li>
              <li>The <span class="code">bind</span> line makes haproxy
                  listen on the port 1000 for incoming requests.</li>
              <li>The <span class="code">acl</span> line matches all
                  requests where the path is
                  <span class="code">/.well-known/acme-challenge/</span>.
                  This match can be referred to using the name
                  <span class="code">url_acme_http01</span> for the rest
                  of the configuration.</li>
              <li>Finally, the http-request
                  <span class="code">http-request</span> line makes all
                  requests matching the named match above be handled by
                  the plugin.</li>
          </ul>
          <p>Now we reload haproxy to make it handle the new
              configuration:</p>
          <pre>systemctl reload haproxy</pre>
          <p>As haproxy will be listening on port 1000 and Let's Encrypt
              will communicate on port 80, we will need to forward the
              external port 80 to the internal port 1000 on the server.
              Using upnpnc:</p>
          <pre>upnpc -a 192.168.1.100 1000 80 tcp</pre>

          <h3>Setup the Certification Bot</h3>
          <p>Installing the Let's Encrypt certification bot is done
              with:</p>
          <pre>sudo pacman -S community/certbot</pre>
          <p>Like said before, the certificate renewal will be automated
              using fcron, so let's install it:</p>
          <pre>sudo pacman -S community/fcron</pre>
            
          <p>Again, the script used to renew the certificates is
              shamelessly adapted from
              <a href="https://blog.brixit.nl/automating-letsencrypt-and-haproxy">martijn's blog</a>.
              I installed it in
              <span class="code">/usr/local/bin/haproxy-ssl-renew</span>:</p>
          <pre>#!/bin/bash

<span class="comment"># Stop the whole script on first error</span>
set -e

<span class="comment"># Path to the letsencrypt-auto tool</span>
LE_TOOL=/usr/bin/certbot

<span class="comment"># Directory where the acme client puts the generated certs</span>
LE_OUTPUT=/etc/letsencrypt/live

<span class="comment"># Directory where the certificates will be stored for Plex to find them</span>
DEST_DIR="/var/lib/plex/Plex Media Server/ssl"

<span class="comment"># Encryption key needed for openssl pkcs12</span>
ENC_KEY=$(cat "$DEST_DIR"/enc.key)

<span class="comment"># Concat the requested domains</span>
DOMAINS=""
for DOM in "$@"
do
    DOMAINS+=" -d $DOM"
done

<span class="comment"># Create or renew certificate for the domain(s) supplied for this tool</span>
$LE_TOOL certonly --agree-tos --renew-by-default --webroot --webroot-path /usr/share/haproxy $DOMAINS

<span class="comment"># Transform the output of certonly to one usable by Plex
<a href="https://forums.plex.tv/discussion/comment/1094600/#Comment_1094600">From this forum post</a></span>
openssl pkcs12 -export -in $LE_OUTPUT/$1/fullchain.pem -inkey $LE_OUTPUT/$1/privkey.pem -out "$DEST_DIR"/archive.pfx -passout pass:$ENC_KEY -name "plex"

<span class="comment"># Reload the haproxy daemon to activate the cert</span>
systemctl reload haproxy</pre>
          <p>This script expects to find a file at
              <span class="code">/var/lib/plex/Plex Media Server/ssl/enc.key</span>
              containing a random key. To generate one, go to
              <a href="https://www.random.org/passwords/?num=5&len=16&format=html&rnd=new">random.org</a>
              and put it in the file using:</p>
          <pre>sudo su plex -s /bin/sh -c 'mkdir /var/lib/plex/Plex\ Media\ Server/ssl'
sudo su plex -s /bin/sh -c 'chmod 700 /var/lib/plex/Plex\ Media\ Server/ssl'
sudo su plex -s /bin/sh -c 'vim /var/lib/plex/Plex\ Media\ Server/ssl/enc.key'</pre>
          <p>All this sudo shenanigans makes all the command executed by
              the plex user (<span class="code">su plex</span>) using
              the sh shell (<span class="code">-s /bin/sh</span>).
              Specifying the shell is needed because by default the plex
              user is not able to login.</p>
          <p>Finally, we can put this script in fcron:</p>
          <pre>sudo fcrontab -e<br>10 4 1 */3 * /usr/local/bin/haproxy-ssl-renew mydream.com</pre>
          <p>Of course, replace <span class="code">mydream.com</span>
              with your domain. With this line, the script will run
              every three month, on the first day of the month, at
              4:10am. You can of course change this to your liking but
              remember that the certifcate will only be valid for four
              months.</p> 
          <p>But we won't wait that long to get our first certificate!
              We will run the script right now:</p>
          <pre>sudo fcrondyn
<span class="comment"># Show all scripts</span>
ls
<span class="comment"># Locate the script we just added, for example:</span>
36 |root |2016-10-01 04:12|/usr/local/bin/plex-ssl-renew mydream.com
<span class="comment"># run it:</span>
runnow 36
</pre>
          
          <h3>Make Plex Use the New Certificates</h3>
          <p>The last step, we are nearly there!</p>
          <p>Go to the plex website
              <a href="http://mydream.com:32400/web">http://mydream.com:32400/web</a>
              and go to the server settings:
              <span class="code">Manage &gt; Settings &gt; Network &gt; Show&nbsp;Advanced</span>
              and fill out the form like this:</p>
          <pre><span class="comment">Custom certificate location:</span>
/var/lib/plex/Plex Media Server/ssl/archive.pfx
<span class="comment">Custom certificate encryption key:</span>
XXXXXXXXXXXXXXXX
<span class="comment">Custom certificate domain:</span>
mydream.com
</pre>
          <p>The encryption key is the one we put in the
              <span class="code">enc.key</span> file above, the one we
              generated on random.org.</p>

          <h2>Success!</h2>
          <p>We did it! We can now access plex through
              <a href="https://mydream.com:32400/web">https://mydream.com:32400/web</a>.
              Notice that your browser accepts the certificate and you
              get a nice green address bar!</p>
      </section>
    </div>

    <footer>
      <div class="container">
          <p>Thanks for reading through, I hope this blog post was
              helpful to you. Got any issue? Don't hesitate to open an
              issue on GitHub.<br> - ibizaman</p>
      </div>
    </footer>
    
  </body>
</html>
